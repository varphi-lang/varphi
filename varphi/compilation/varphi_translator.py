"""varphi/parsing_tools/varphi_representor.py"""

from ..parsing import VarphiParser, VarphiListener


class VarphiTranslator(VarphiListener):
    """This class translates the tokens generated by VarphiParser into Python code."""

    translated_program: str
    initial_state_found: bool
    seen_state_names: set[str]

    def enterLine(self, ctx: VarphiParser.LineContext) -> None:
        raise NotImplementedError


class VarphiTranslatorCLITarget(VarphiTranslator):
    """This class translates the tokens generated by VarphiParser into Python code."""

    def __init__(self):
        """Initialize a VarphiRepresentor."""
        self.translated_program = "if __name__ == '__main__':\n"
        self.translated_program += (
            "    from varphi.runtime.types import "
            "TapeCharacter, HeadDirection, Instruction, State\n"
        )
        self.translated_program += "    initial_state = None\n"
        self.initial_state_found = False
        self.seen_state_names = set()
        super().__init__()

    def enterLine(
        self, ctx: VarphiParser.LineContext
    ) -> None:  # pylint: disable=R0914, R0912, R0915
        """Enter a parse tree produced by VarphiParser#line.

        Processes the parse tree nodes to extract state transitions and
        instructions.

        Args:
            - ctx (VarphiParser.LineContext): The context for the parse tree
              node.
        """
        if_state_string = str(ctx.STATE(0).getText())
        if if_state_string not in self.seen_state_names:
            self.translated_program += f"    {if_state_string} = State()\n"
            if not self.initial_state_found:
                self.translated_program += (
                    f"    initial_state = {str(ctx.STATE(0).getText())}\n"
                )
                self.initial_state_found = True
            self.seen_state_names.add(if_state_string)

        then_state_string = str(ctx.STATE(1).getText())
        if then_state_string not in self.seen_state_names:
            self.translated_program += f"    {str(ctx.STATE(1).getText())} = State()\n"
            self.seen_state_names.add(then_state_string)

        instruction = f"Instruction({then_state_string}, "
        if str(ctx.TAPE_CHARACTER(1).getText()) == "1":
            instruction += "TapeCharacter.TALLY, "
        else:
            instruction += "TapeCharacter.BLANK, "

        if str(ctx.HEAD_DIRECTION().getText()) == "R":
            instruction += "HeadDirection.RIGHT)"
        else:
            instruction += "HeadDirection.LEFT)"

        if str(ctx.TAPE_CHARACTER(0).getText()) == "1":
            self.translated_program += (
                f"    {str(ctx.STATE(0).getText())}.add_on_tally_instruction("
                f"{instruction})\n"
            )
        else:
            self.translated_program += (
                f"    {str(ctx.STATE(0).getText())}.add_on_blank_instruction("
                f"{instruction})\n"
            )


class VarphiTranslatorCLIDebuggerTarget(VarphiTranslator):
    """This class translates the tokens generated by VarphiParser into Python code."""

    def __init__(self):
        """Initialize a VarphiRepresentor."""
        self.translated_program = "if __name__ == '__main__':\n"
        self.translated_program += (
            "    from varphi.runtime.types import "
            "TapeCharacter, HeadDirection, Instruction, NamedState\n"
        )
        self.translated_program += "    initial_state = None\n"
        self.initial_state_found = False
        self.seen_state_names = set()
        super().__init__()

    def enterLine(
        self, ctx: VarphiParser.LineContext
    ) -> None:  # pylint: disable=R0914, R0912, R0915
        """Enter a parse tree produced by VarphiParser#line.

        Processes the parse tree nodes to extract state transitions and
        instructions.

        Args:
            - ctx (VarphiParser.LineContext): The context for the parse tree
              node.
        """
        if_state_string = str(ctx.STATE(0).getText())
        if if_state_string not in self.seen_state_names:
            self.translated_program += (
                f'    {if_state_string} = NamedState("{if_state_string}")\n'
            )
            if not self.initial_state_found:
                self.translated_program += (
                    f"    initial_state = {str(ctx.STATE(0).getText())}\n"
                )
                self.initial_state_found = True
            self.seen_state_names.add(if_state_string)

        then_state_string = str(ctx.STATE(1).getText())
        if then_state_string not in self.seen_state_names:
            self.translated_program += (
                f"    {str(ctx.STATE(1).getText())} = "
                f'NamedState("{then_state_string}")\n'
            )
            self.seen_state_names.add(then_state_string)

        instruction = f"Instruction({then_state_string}, "
        if str(ctx.TAPE_CHARACTER(1).getText()) == "1":
            instruction += "TapeCharacter.TALLY, "
        else:
            instruction += "TapeCharacter.BLANK, "

        if str(ctx.HEAD_DIRECTION().getText()) == "R":
            instruction += "HeadDirection.RIGHT)"
        else:
            instruction += "HeadDirection.LEFT)"

        if str(ctx.TAPE_CHARACTER(0).getText()) == "1":
            self.translated_program += (
                f"    {str(ctx.STATE(0).getText())}.add_on_tally_instruction("
                f"{instruction})\n"
            )
        else:
            self.translated_program += (
                f"    {str(ctx.STATE(0).getText())}.add_on_blank_instruction("
                f"{instruction})\n"
            )


class VarphiTranslatorCLIDebugAdapterTarget(VarphiTranslator):
    """This class translates the tokens generated by VarphiParser into Python code."""

    def __init__(self):
        """Initialize a VarphiRepresentor."""
        self.translated_program = "if __name__ == '__main__':\n"
        self.translated_program += (
            "    from varphi.runtime.types import "
            "TapeCharacter, HeadDirection, LineNumberedInstruction, NamedState\n"
        )
        self.translated_program += "    initial_state = None\n"
        self.initial_state_found = False
        self.seen_state_names = set()
        super().__init__()

    def enterLine(
        self, ctx: VarphiParser.LineContext
    ) -> None:  # pylint: disable=R0914, R0912, R0915
        """Enter a parse tree produced by VarphiParser#line.

        Processes the parse tree nodes to extract state transitions and
        instructions.

        Args:
            - ctx (VarphiParser.LineContext): The context for the parse tree
              node.
        """
        if_state_string = str(ctx.STATE(0).getText())
        if if_state_string not in self.seen_state_names:
            self.translated_program += (
                f'    {if_state_string} = NamedState("{if_state_string}")\n'
            )
            if not self.initial_state_found:
                self.translated_program += (
                    f"    initial_state = {str(ctx.STATE(0).getText())}\n"
                )
                self.initial_state_found = True
            self.seen_state_names.add(if_state_string)

        then_state_string = str(ctx.STATE(1).getText())
        if then_state_string not in self.seen_state_names:
            self.translated_program += (
                f"    {str(ctx.STATE(1).getText())} = "
                f'NamedState("{then_state_string}")\n'
            )
            self.seen_state_names.add(then_state_string)

        instruction = f"LineNumberedInstruction({then_state_string}, "
        if str(ctx.TAPE_CHARACTER(1).getText()) == "1":
            instruction += "TapeCharacter.TALLY, "
        else:
            instruction += "TapeCharacter.BLANK, "

        if str(ctx.HEAD_DIRECTION().getText()) == "R":
            instruction += f"HeadDirection.RIGHT, {ctx.start.line})"
        else:
            instruction += f"HeadDirection.LEFT, {ctx.start.line})"

        if str(ctx.TAPE_CHARACTER(0).getText()) == "1":
            self.translated_program += (
                f"    {str(ctx.STATE(0).getText())}.add_on_tally_instruction("
                f"{instruction})\n"
            )
        else:
            self.translated_program += (
                f"    {str(ctx.STATE(0).getText())}.add_on_blank_instruction("
                f"{instruction})\n"
            )
